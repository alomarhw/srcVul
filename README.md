# srcVul
srcVul: Detecting Security Vulnerabilities in Code Clones using Scalable and Efficient Slicing-Based Techniques

The srcVul system is designed to identify security vulnerabilities in code clones using a methodical three-stage process. It focuses on extracting non-contiguous, re-ordered, and intertwined statements related to vulnerabilities (ùëâ ùëÖùë†ùë°ùëöùë°ùë†) from well-documented vulnerable programs and their corresponding patches for specific known vulnerabilities. This process includes:

Slicing and Comparison: The vulnerable program and its associated patch are subjected to slicing and comparison. This stage is crucial in generating a list of vulnerability-related slices (ùëâ ùëÖùë†ùëôùëñùëêùëíùë†) that contain ùëâ ùëÖùë†ùë°ùëöùë°ùë†.
Cloning Detection: The ùëâ ùëÖùë†ùëôùëñùëêùëíùë†, obtained from the previous stage, are systematically compared to pinpoint their clones within slices of the target program.
To achieve this, srcVul leverages the capabilities of srcML (available at https://www.srcml.org) and srcSlice (found at https://www.srcml.org/tools.html). Additionally, the source code of srcSlice can be accessed on GitHub at https://github.com/srcML/srcSlice.

%%%%%%%%%%%%%%%%%%%%

Below is a detailed breakdown of the key steps from generating srcML of the source code to finding vulnerabilities. Here‚Äôs an overview of the steps involved:
Convert the source code to srcML representation
1.	Download srcML:
       First, you‚Äôll need to install srcML. You can download it from the official srcML website: https://www.srcml.org
  	   Installation instructions can usually be found on the website: https://www.srcml.org/#download. 

2.	Convert Source Code to XML using srcML:
    a.	Once you have srcML installed, you can use it to convert your source code into an XML representation that preserves the code‚Äôs syntax information.
    b.	If you're using Linux or macOS, run the following command in your terminal: 
    	~/srcML/build/bin/srcml 'input_code_file_or_archive_url' > 'output_file' --position
    c. 	If you're using Windows, run the following command in Powershell as administrator:
	& 'path_to_srcML\srcml.exe' 'input_code_file_or_archive_url' > 'output_file.xml' --position	
    d.	Replace ‚Äúinput_code_file_or_archive_url‚Äù with the name of the file containing your source code or the URL of the code you want to analyze.
    e.	Replace "output_file" with the name of the file where you want to save the srcML output.
    f.	The --position option is important because it tells srcML to include the position information for identifiers in the code. This position information is crucial for the subsequent steps when srcSlice performs its computations.
    i.	The output file generated by srcML will be in XML format. It will contain structured information about your source code, including the syntax tree, code elements, and their positions within the code. The XML output allows srcSlice to understand and analyze the code effectively.

3.	Download srcSlice: 
    I.	If you are using Linux, you can follow below steps:
    a.	Visit https://www.srcml.org/tools.html and download srcSlice, a tool for generating code slice profiles.
    b.	Run srcSlice: Use the command. ./srcSlice ‚Äúname of the srcML archive‚Äù in your terminal. This will utilize the srcML representation of your source code to create slicing results.
    c.	System Dictionary Creation: srcSlice will create a system dictionary containing detailed slice profiles for all identifiers present in your code. These profiles encompass definitions (def), uses (use), dependent variables (dvars), pointers (ptrs), and called functions (cfuncs).
    d.	Refer to Tutorials: For a comprehensive understanding of the slicing results and how to interpret them, refer to tutorials like the YouTube video at: https://www.youtube.com/watch?v=fk9JiIi032U&t=80s. These resources provide valuable insights into analyzing the generated slicing profiles.

    II.	Running srcSlice on Windows (Using WSL):
	If you don't have Linux installed on your Windows machine, follow the steps below to set up WSL (Windows Subsystem for Linux). If you have, then proceed from step c.
    a.           Install WSL (Windows Subsystem for Linux):
	Open PowerShell as Administrator and run the following command to install WSL: wsl --install
	By default, this will install Ubuntu as your Linux distribution.

    b.           Launch Ubuntu (WSL):
	Open the Ubuntu terminal from your Start menu after installation.
	Follow the prompts to create a new user.

    c.	Download srcSlice:
	Visit the srcSlice website (https://www.srcml.org/tools.html) and download the srcSlice tool (a .tar.gz file) for Ubuntu, e.g., srcslice-ubuntu-14.04.tar.gz.
	Place the downloaded file in a directory accessible to WSL, for example: C:\Users\YourUsername\Downloads.

    d. 	Extract the srcSlice Archive:
	Open your Ubuntu terminal and navigate to the directory where you downloaded the srcslice-ubuntu-14.04.tar.gz file, for example: cd /mnt/c/Users/YourUsername/Downloads
	Extract the .tar.gz file: tar -xvzf srcslice-ubuntu-14.04.tar.gz
	This will create a folder containing the srcslice binary.

    e.	Set Permissions:
	After extraction, navigate to the folder where srcslice was extracted: cd srcslice-ubuntu-14.04
	Make the srcslice binary executable: chmod +x srcslice-ubuntu-14

    f.	Run srcSlice:
	Run the srcslice executable, specifying your srcML archive as follows: ./srcslice-ubuntu-14 your-srcML-file.xml
	For example: ./srcslice-ubuntu-14 srcMLOutput.xml

    g.	System Dictionary Creation:
	The slice profiles are created containing definitions (def), uses (use), dependent variables (dvars), pointers (ptrs), and called functions (cfuncs).

4.   Calculate Slice-based Metrics and Generate Slicing Vectors
	This step explains how to calculate slice-based metrics using the provided C# code and provides instructions for running the C# solution to generate slicing vectors from the calculated metrics.

    Part 1:    Explanation of Slice-based Metrics
    	In this step, we will calculate the slice-based metrics for each slice: Slice Count (SC), Slice Size (SZ), Slice Coverage (SCvg), Slice Identifier (SI), and Slice Spatial (SS) using the provided C# code. These metrics provide valuable insights into code characteristics and complexity.
1.	Slice Count (SC): This metric quantifies the number of slices in relation to the module size. 
		           For variables, it indicates the number of slice profiles combined to form the final slice. Mathematically, SC (var) = Slice_Profile (SP) / Module_Size, where SP (var) = (1 + DVars.Count + Ptrs.Count), 1 is for the variable itself.
		           For functions, it represents the total count of slices encompassing all variables within the function. 
		           For files, it corresponds to the count of slices associated with functions in that file.
2.	Slice Size (SZ): This metric represents the total number of statements within a complete final slice and plays a role in calculating the SCvg metric. 
		       For a variable, SZ is the count of the union of the lines where the variable is defined and used. Mathematically, SZ (var) = (def(var) ‚à™ use(var)).Count
3.	Slice Coverage (SCvg): SCvg measures the slice size relative to the module size, quantified in lines of code (LoC). 
			  Mathematically, SCvg = SZ / Module_Size
4.	Slice Identifier (SI): SI counts the unique identifiers, including variables and method invocations, contained within a slice relative to the module‚Äôs size. These identifiers are drawn from the Dvars, Ptrs, and Cfuncs fields within the slice. 
		               Mathematically, SI = (DVars.Count + Ptrs.Count + CFuncs.Count) / Module_Size
5.	Slice Spatial (SS): SS represents the spatial distance in LoC between the initial definition and the ultimate use of the slicing variable. This value is divided by the module size.
		           Mathematically, SS = (Sl - Sf) / Module_Size, where Sf denotes the first statement in the slice, Sl stands for the last statement in the slice.

    Part 2:   Instructions for running the C# solution
  1.	Open the Solution File (SlicingVector_Generator.sln) in a text editor.   
    I. 	In Visual Studio Code:
      a.	Open the folder containing the solution file in VS Code. You can do this by clicking File ‚Üí Open Folder
      b.	Install the C# extension by Microsoft if not already installed. Go to the Extensions view (Ctrl + Shift + X), search for "C#", and install the extension.
      c.	Press Ctrl + F5 to run the project without debugging or click on the Run button in the toolbar.

   II.	In Visual Studio: 
      a.          Launch Visual Studio.
      b.	Click File ‚Üí Open ‚Üí Project/Solution.
      c.	Navigate to the directory and open the SlicingVector_Generator.sln file.
      d.	Click Build ‚Üí Build Solution (or press Ctrl + Shift + B) to build the project.
      e.	Click Debug ‚Üí Start Debugging (or press F5) to run the solution.

  2.	Input Requirements:
	Once the program starts, it will prompt for the following:
    a.           	Path to the code file: This file is used to calculate the module size.
    b.           Path to the slice profile file: The program will read this file to extract the slice profiles, including definitions, uses, dependent variables, pointers, and called functions.
 
 3.	Database output:
	The metrics (SC, SZ, SCvg, SI, SS) for each slice are calculated and stored in an SQLite database (vectors.db). The database will contain the following fields:
    a.	MethodName: The name of the method.
    b.	VariableName: The variable name.
    c.	SC: Slice Count.
    d.	SZ: Slice Size.
    e.	SCvg: Slice Coverage.
    f.	SI: Slice Identifier.
    g.	SS: Slice Spatial.